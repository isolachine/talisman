/*
 * Copyright (c) 2003-Present Alex Kinneer. All rights reserved.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

package sir.mts;

/**
 * <p>Records the settings that control various aspects of the operation
 * of MakeTestScript.</p>
 *
 * @author Alex Kinneer
 * @version 02/14/2006
 */
public final class Configuration {
    /** Command string used to invoke MakeTestScript. */
    private String invokeString;

    /** Name of the STImpL input file. */
    private String stimpleFile;
    /** Name of the script file to be generated. */
    private String scriptName;
    /** Path to the experiment root directory. */
    private String expDir = "..";
    /** String to be inserted at the front of the entire invocation command. */
    private String prefix;
    /** String to be appended to the entire invocation command. */
    private String suffix;
    /** Name of the subject executable/main class. */
    private String exeName;
    /** String to be inserted at the front of the executable name. */
    private String exePrefix;
    /** String to be appended to the executable name. */
    private String exeSuffix;
    /** Command to invoke in comparison scripts to check file equivalence. */
    private String diffCmd = "cmp -s";
    /** Path to the directory containing the old files to be compared against
        in a comparison script. */
    private String compareDir;
    /** Path to the directory where trace files are generated by the
        program tracing tool, used in trace scripts. */
    private String traceSourceDir;
    /** Name of the trace file generated, used in trace scripts. */
    private String traceName;

    /** Flag specifying that a comparison script is to be generated. */
    private boolean isComparing = false;
    /** Flag specifying that a trace script is to be generated. */
    private boolean isTracing = false;
    /** Flag indicating the the subject is a Java program. */
    private boolean isJava = false;
    /** Specifies the target script type. Certain shorthand strings
        may be understood. */
    private String targetType = "csh";

    /** Flag to disable recognition of escape sequences by the lexer. */
    private boolean disableEscapes = false;
    /** Flag to enable recognition of the old substition macro(s). */
    private boolean enableLegacyMacros = false;
    /** Flag specifing that the executable suffix should be constrained
        to STImpL file lines containing the '-D' command (to emulate
        the behavior of the old mts tool). */
    private boolean exeSuffixConstrain;

    /** Constant specifying the path the to subject inputs directory. */
    public static final String INPUT_DIR = "/inputs";
    /** Constant specifying the path the to subject outputs directory. */
    public static final String OUTPUT_DIR = "/outputs";
    /** Constant specifying the path the to subject traces directory. */
    public static final String TRACE_DIR = "/traces";
    /** Constant specifying the path the to subject testscripts directory,
        used to locate scripts referenced by STImpL script commands. */
    public static final String TESTSCRIPT_DIR = "/testplans.alt/testscripts";
    /** Constant specifying the default path to the trace file source for
        Sofya. */
    public static final String SOFYA_DB_DIR = "${SOFYA_DB_DIR}";
    /** Constant specifying the default path to the trace file source for
        Aristotle. */
    public static final String ARISTOTLE_DB_DIR = "${ARISTOTLE_DB_DIR}";

    /**
     * Creates a new configuration with default values where appropriate.
     */
    public Configuration() {
        super();
    }

    /**
     * Records the command line string used to invoke MakeTestScript.
     *
     * @param cls Name of the class file used to invoke MakeTestScript.
     * @param argv Arguments passed to the class.
     */
    public void setMTSCommandString(String cls, String[] argv) {
        StringBuffer cmdline = new StringBuffer("java ");
        cmdline.append(cls);
        for (int i = 0; i < argv.length; i++) {
            cmdline.append(" \"");
            cmdline.append(argv[i]);
            cmdline.append("\"");
        }
        invokeString = cmdline.toString();
    }

    /**
     * Gets the command line string used to invoke MakeTestScript.
     *
     * @return The command line string used to invoke MakeTestScript.
     */
    public String getMTSCommandString() {
        return invokeString;
    }

    /**
     * Sets the name of the STImpL file to be processed.
     *
     * @param name Name of the STImpL file from which to generate a script.
     */
    public void setStimpleFile(String name) {
        this.stimpleFile = name;
    }

   /**
    * Gets the name of the STImpL file to be processed.
    *
    * @return The name of the STImpL file from which to generate a script.
    */
   public String getStimpleFile() {
        return stimpleFile;
    }

    /**
     * Sets the name of the script to be generated.
     *
     * @param name Name of the script to be generated.
     */
    public void setScriptName(String name) {
        this.scriptName = name;
    }

    /**
     * Gets the name of the script to be generated.
     *
     * @return The name of the script to be generated.
     */
    public String getScriptName() {
        return scriptName;
    }

    /**
     * Sets the path to the experiment root directory of the subject.
     *
     * @param expDir Path to the experiment root directory of the subject.
     */
    public void setExperimentDirectory(String expDir) {
        this.expDir = expDir;
    }

    /**
     * Gets the path to the experiment root directory of the subject.
     *
     * @return Path to the experiment root directory of the subject.
     */
    public String getExperimentDirectory() {
        return expDir;
    }

    /**
     * Sets the name of the executable program to be invoked.
     *
     * @param exeName Name of the executable to be invoked.
     */
    public void setSubjectExecutable(String exeName) {
        this.exeName = exeName;
    }

    /**
     * Gets the name of the executable program to be invoked.
     *
     * @return The name of the executable to be invoked.
     */
    public String getSubjectExecutable() {
        return exeName;
    }

    /**
     * Sets a prefix to be prepended to the executable name.
     *
     * @param exePrefix String that will be prepended to the executable name.
     */
    public void setExecutablePrefix(String exePrefix) {
        this.exePrefix = exePrefix;
    }

    /**
     * Gets the prefix that will be prepended to the executable name.
     *
     * @return String that will be prepended to the executable name.
     */
    public String getExecutablePrefix() {
        return exePrefix;
    }

    /**
     * Sets a suffix to be appended to the executable name.
     *
     * @param exeSuffix String that will be appended to the executable name.
     */
    public void setExecutableSuffix(String exeSuffix) {
        this.exeSuffix = exeSuffix;
    }

    /**
     * Gets the suffix that will be appended to the executable name.
     *
     * @return String that will be appended to the executable name.
     */
    public String getExecutableSuffix() {
        return exeSuffix;
    }

    /**
     * Sets a flag indicating that the executable suffix should be appended
     * only on test cases specifying a test driver (with the STImpL
     * &apos;-D&apos; command).
     *
     * @param on <code>true</code> to enable, <code>false</code> otherwise.
     */
    public void setExecutableSuffixConstrained(boolean on) {
        this.exeSuffixConstrain = on;
    }

    /**
     * Checks the flag specifying whether the executable suffix will be
     * appended only on test cases specifying a test driver (with the STImpL
     * &apos;-D&apos; command).
     *
     * @return boolean <code>true</code> if the suffix appended only on
     * test cases specifying a test driver, <code>false</code> otherwise.
     */
    public boolean isExecutableSuffixConstrained() {
        return exeSuffixConstrain;
    }

    /**
     * Sets a prefix to be inserted before the entire test case invocation
     * command.
     *
     * <p>The prefix is inserted with separating whitespace.</p>
     *
     * @param invPrefix String to be inserted before the entire
     * test case invocation command.
     */
    public void setInvokePrefix(String invPrefix) {
        this.prefix = invPrefix;
    }

    /**
     * Gets the prefix that will be inserted before the entire test case
     * invocation command.
     *
     * @return String that will be inserted before the entire test case
     * invocation command.
     */
    public String getInvokePrefix() {
        return prefix;
    }

    /**
     * Sets a suffix that will be appended to the end of the entire test case
     * invocation command.
     *
     * <p>The suffix is appended with a separating whitespace.</p>
     *
     * @param invSuffix String to be appended to the end of the entire test
     * case invocation command.
     */
    public void setInvokeSuffix(String invSuffix) {
        this.suffix = invSuffix;
    }

    /**
     * Gets the suffix that will be appended to the end of the entire test
     * case invocation command.
     *
     * @return String that will be appended to the end of the entire test
     * case invocation command.
     */
    public String getInvokeSuffix() {
        return suffix;
    }

    /**
     * Sets whether the script to be generated is an output comparing script.
     *
     * @param on <code>true</code> to generate a script that compares
     * outputs, <code>false</code> otherwise.
     */
    public void setComparing(boolean on) {
        this.isComparing = on;
    }

    /**
     * Reports whether the script to be generated is an output comparing script.
     *
     * @return <code>true</code> if the generated script will compare outputs,
     * <code>false</code> otherwise.
     */
    public boolean isComparing() {
        return isComparing;
    }

    /**
     * Sets the command to be used for comparing outputs in comparison scripts.
     *
     * <p>If this method is not called, a default value is used.</p>
     *
     * @param diffCmd Command, and any associated options, that should be used
     * for comparing output files by a comparison script.
     */
    public void setComparisonCommand(String diffCmd) {
        this.diffCmd = diffCmd;
    }

    /**
     * Gets the command to be used for comparing outputs in comparison scripts.
     *
     * @return The command, and any associated options, that will be used
     * to compare output files by a generated comparison script.
     */
    public String getComparisonCommand() {
        return diffCmd;
    }

    /**
     * Sets the path to the directory containing the files against which
     * outputs should be compared by a comparison script.
     *
     * <p>This method must be called before attempting to generate a
     * comparison script.</p>
     *
     * @param compareDir Path to the directory containing previous outputs
     * against which the current outputs should be compared by the
     * generated comparison script.
     */
    public void setComparisonDirectory(String compareDir) {
        if (compareDir.endsWith("/")) {
            this.compareDir = compareDir.substring(0, compareDir.length() - 1);
        }
        else {
            this.compareDir = compareDir;
        }
    }

    /**
     * Gets the path to the directory containing the files against which
     * outputs should be compared by a comparison script.
     *
     * @return The path to the directory containing previous outputs against
     * which the current outputs should be compared by the generated
     * comparison script.
     */
    public String getComparisonDirectory() {
        return compareDir;
    }

    /**
     * Sets whether the script to be generated is a trace collecting script.
     *
     * @param on <code>true</code> to generate a script that collects traces,
     * <code>false</code> otherwise.
     */
    public void setTracing(boolean on) {
        this.isTracing = on;
    }

    /**
     * Reports whether the script to be generated is a trace collecting script.
     *
     * @return <code>true</code> if the generated script will collect traces,
     * <code>false</code> otherwise.
     */
    public boolean isTracing() {
        return isTracing;
    }

    /**
     * Sets the path to the directory where the trace files produced by the
     * tracing tool in use can be found.
     *
     * @param traceDir Path to the directory where trace files produced by
     * the tracing tool in use can be found.
     */
    public void setTraceSourceDirectory(String traceDir) {
        if (traceDir.endsWith("/")) {
            this.traceSourceDir = traceDir.substring(0, traceDir.length() - 1);
        }
        else {
            this.traceSourceDir = traceDir;
        }
    }

    /**
     * Gets the path to the directory where the trace files produced by the
     * tracing tool in use can be found.
     *
     * @return The path to the directory where trace files produced by the
     * tracing tool in use can be found.
     */
    public String getTraceSourceDirectory() {
        return traceSourceDir;
    }

    /**
     * Sets the name of the trace file generated by the tracing tool,
     * which must be invariant.
     *
     * @param traceName Name of the trace file generated by the tracing tool
     * in use.
     */
    public void setTraceName(String traceName) {
        this.traceName = traceName;
    }

    /**
     * Gets the name of the trace file generated by the tracing tool.
     *
     * @return The name of the trace file generated by the tracing tool in use.
     */
    public String getTraceName() {
        return traceName;
    }

    /**
     * Sets a flag indicating whether the subject program to be tested
     * by the generated script is a Java program.
     *
     * <p>This configuration option is a shorthand to automatically set
     * various options to values that yield compatibility with the output
     * of the old <code>javamts</code> tool. It is purely a convenience.</p>
     *
     * @param on boolean <code>true</code> to indicate that the subject
     * to be tested by the generated script is a Java program.
     */
    public void setJava(boolean on) {
        this.isJava = on;
    }

    /**
     * Reports whether the subject program to be tested by the generated
     * script has been indicated to be a Java program.
     *
     * @return boolean <code>true</code> if the program to be tested by the
     * generated script has been indicated to be a Java program.
     */
    public boolean isJava() {
        return isJava;
    }

    /**
     * Sets the target type of script to be generated (such as C shell,
     * Bourne shell, etc).
     *
     * @param targetType String that is either a shorthand identifier for a
     * target script type that is understood by <code>MakeTestScript</code>,
     * or the name of a class implementing the {@link TestScriptGenerator}
     * interface (which must be found on the classpath).
     */
    public void setTargetType(String targetType) {
        this.targetType = targetType;
    }

    /**
     * Gets the target type of script to be generated (such as C shell,
     * Bourne shell, etc).
     *
     * @return String that is either a shorthand identifier for a target
     * script type that is understood by <code>MakeTestScript</code>, or the
     * name of a class implementing the {@link TestScriptGenerator}
     * interface (which must be found on the classpath).
     */
    public String getTargetType() {
        return targetType;
    }

    /**
     * Specifies whether the new escape character capabilities of the
     * <code>MakeTestScript</code> lexer should be disabled.
     *
     * <p>This option supports backwards compatibility with existing
     * universe (STImpL) files. Universe files should be updated whenever
     * possible, after which this option is unneeded.</p>
     *
     * @param on <code>true</code> to disable slash-escapes in the
     * lexer, <code>false</code> otherwise.
     */
    public void disableEscapes(boolean on) {
        this.disableEscapes = on;
    }

    /**
     * Reports whether the new escape character capabilities of the
     * <code>MakeTestScript</code> lexer are disabled.
     *
     * @return <code>true</code> if the slash-style escape sequences are
     * disabled in the <code>MakeTestScript</code> lexer.
     */
    public boolean disableEscapes() {
        return disableEscapes;
    }

    /**
     * Specifies whether legacy substitution macros should be enabled.
     *
     * <p>This currently enables only one macro, the &apos;%n%&apos; macro
     * used to substitute the current test number in file move (&apos-F&apos)
     * STImpL commands. The preferred replacement is to use the new STImpL
     * macro command &quot;\{TEST}&quot; for current test number substitution,
     * which works anywhere.</p>
     *
     * @param on <code>true</code> to enable legacy substitution macros,
     * <code>false</code> otherwise.
     */
    public void enableLegacyMacros(boolean on) {
        this.enableLegacyMacros = on;
    }

    /**
     * Reports whether legacy substitution macros are enabled.
     *
     * @return <code>true</code> if legacy substitution macros are enabled,
     * <code>false</code> otherwise.
     */
    public boolean enableLegacyMacros() {
        return enableLegacyMacros;
    }

    /**
     * Checks that the configuration is consistent and complete.
     *
     * <p>This method may attempt to guess certain configuration values if
     * they are absent. Messages will be printed to the console
     * if this occurs.</p>
     *
     * @throws ConfigurationException If a required configuration value
     * is absent and cannot be reasonably guessed.
     */
    public void validate() throws ConfigurationException {
        if (stimpleFile == null) {
            throw new ConfigurationException("You must specify the name of a " +
                                             "STImpL file");
        }

        if (scriptName == null) {
            throw new ConfigurationException("You must specify a name for " +
                                             "the script to be generated");
        }

        if (exeName == null) {
            throw new ConfigurationException("You must specify the executable "+
                                             "name of the subject");
        }

        if (isComparing && (compareDir == null)) {
            throw new ConfigurationException("You must specify a directory " +
                                             "to use in comparing outputs");
        }

        if (isTracing) {
            if (traceSourceDir == null) {
                if (isJava) {
                    traceSourceDir = SOFYA_DB_DIR;
                }
                else if ((prefix != null) && (prefix.indexOf("java") != -1)) {
                    System.err.println("WARN: No trace file source directory " +
                                       "was specified. MakeTestScript is " +
                                       "guessing\nyou want the Sofya " +
                                       "database directory.");
                    traceSourceDir = SOFYA_DB_DIR;
                }
                else {
                    System.err.println("WARN: No trace file source directory " +
                                       "was specified. MakeTestScript is " +
                                       "guessing\nyou want the Aristotle " +
                                       "database directory.");
                    traceSourceDir = ARISTOTLE_DB_DIR;
                }
            }
            if (traceName == null) {
                if (isJava) {
                    traceName = "instout.tr";
                }
                else if ((prefix != null) && (prefix.indexOf("java") != -1)) {
                    System.out.println("INFO: No trace name was specified. " +
                                       "MakeTestScript is guessing you want\n" +
                                       "\"instout.tr\".");
                    traceName = "instout.tr";
                }
                else {
                    System.out.println("INFO: No trace name was specified. " +
                                       "MakeTestScript is guessing you want\n" +
                                       "<subject-exe>.c.tr.");
                    traceName = exeName + ".c.tr";
                }
            }
        }

        if (isJava) {
            if (prefix == null) {
                prefix = "java";
            }
            else if (!prefix.startsWith("java")) {
                prefix = prefix + " java";
            }
        }
    }

    /**
     * Produces a string representation of the current configuration.
     *
     * @return A string reporting the current values of all configuration
     * parameters.
     */
    public String toString() {
        StringBuffer text = new StringBuffer();

        text.append("Command line = ").append(invokeString).append("\n");
        text.append("STImpL file = ").append(stimpleFile).append("\n");
        text.append("Script name = ").append(scriptName).append("\n");
        text.append("Experiment directory = ").append(expDir).append("\n");
        text.append("Executable name = ").append(exeName).append("\n");
        text.append("Executable prefix = ").append(exePrefix).append("\n");
        text.append("Executable suffix = ").append(exeSuffix).append("\n");
        text.append("Invoke prefix = ").append(prefix).append("\n");
        text.append("Invoke suffix = ").append(suffix).append("\n");
        text.append("Comparison script [").append(isComparing).append("]\n");
        if (isComparing) {
            text.append("  directory = ").append(compareDir).append("\n");
            text.append("  command = \"").append(diffCmd).append("\"\n");
        }
        text.append("Tracing script [").append(isTracing).append("]\n");
        if (isTracing) {
            text.append("  source directory = ").append(traceSourceDir)
                    .append("\n");
            text.append("  trace name = ").append(traceName).append("\n");
        }
        text.append("Java flag activated [").append(isJava).append("]\n");
        text.append("Escapes disabled [").append(disableEscapes).append("]\n");
        text.append("Legacy macros enabled [").append(enableLegacyMacros)
                .append("]\n");
        text.append("Constrain executable suffix [")
                .append(exeSuffixConstrain).append("]");

        return text.toString();
    }
}
