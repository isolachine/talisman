#include "CallGraphHelper.h"

#define DEBUG 0


void CallGraphHelper::initialize_call_map() {
    int node_id_counter = 0;
    errs() << "Generating call graph...\n";
    //Traverse call graph and generate a copy of each node
    for (scc_iterator<CallGraph *> I = scc_begin(CG); !I.isAtEnd(); ++I) {
        vector<CallGraphNode *> SCC = *I;

        for (unsigned i = 0, e = SCC.size(); i != e; ++i) {
            Function *F = SCC[i]->getFunction();
            if (!F) {
                break;
            }
            else
            {
                if (call_graph_map[SCC[i]->getFunction()->getName().str()])
                {
                    errs() << "Overloaded functions detected...call graph imprecise\n";
                }
                else
                {
                    call_graph_map[SCC[i]->getFunction()->getName().str()] = new CallNode(node_id_counter++, SCC[i]->getFunction());
                    call_graph_map[SCC[i]->getFunction()->getName().str()]->num_references = SCC[i]->getNumReferences();
                }

            }
        }

        //Re-Iterate and set up successors
        for (unsigned i = 0, e = SCC.size(); i != e; ++i) {
            Function *F = SCC[i]->getFunction();
            if (!F) {
                break;
            }
            else
            {
                for(auto edge_it = SCC[i]->begin(); edge_it != SCC[i]->end(); edge_it++) {
                    Function *temp_function = edge_it->second->getFunction();

                    // If the function is not NULL we can generate a node and identify information
                    if (temp_function != NULL)
                    {
                        call_graph_map[SCC[i]->getFunction()->getName().str()]->successor_list.push_back(
                                call_graph_map[edge_it->second->getFunction()->getName().str()]);
                    }
                }
            }
        }
    }


    errs() << "Verifying call graph...\n";
    /*
     * The default call graph generated by LLVM is not as accurate as we would like.
     *
     * It seems call instructions with bit-casting are not properly handled.
     * We have to re-iterate through the code and add necessary nodes and edges to the call graph
     *
     */
    for (auto f_func = M->functions().begin(); f_func != M->functions().end(); f_func++) {
        for (auto f_block = f_func->begin(); f_block != f_func->end(); f_block++) {
            for (auto f_inst = f_block->begin(); f_inst != f_block->end(); f_inst++) {

                if (CallInst * call_inst = dyn_cast<CallInst>(f_inst)) {
                    std::string call_inst_string;
                    raw_string_ostream rso(call_inst_string);
                    call_inst->print(rso);

                    std::string call_post_substring = call_inst_string.substr(call_inst_string.find('@') + 1, call_inst_string.size()-1);
                    std::string callee = call_post_substring.substr(0, call_post_substring.find("("));

                    if (callee.find(" ") != std::string::npos) {
                        callee = callee.substr(0, callee.find(" "));
                    }

                    /*
                     * At this point we have a call instruction and have parsed the instruction string for the callee
                     *
                     * We parse the call instruction string for generality and to capture all types of call instructions
                     * Next we check if a call node exists for a given callee. Note that we ignore asm calls as these
                     * are not handled well by LLVM and is not something we have explored for this research.
                     *
                     *
                     * Example logic for check
                     * If a call node for the callee exists,
                     *      We check if the caller->callee edge exists and add it if not
                     *
                     * If a call node does not exist we may want to add one.
                     */

                    if ((call_inst_string.find(" asm ") == std::string::npos) &&
                        (call_inst_string.find("llvm.") == std::string::npos) &&
                        (call_inst_string.find("mutex_lock") == std::string::npos) &&
                        (call_inst_string.find("mutex_unlock") == std::string::npos) &&
                        (call_inst_string.find("slow_avc_audit") == std::string::npos) &&
                        (call_graph_map[f_func->getName()])) {

                        if (!call_graph_map[callee]) {
                            //errs() << "Call node not found for function " << callee << "       from        " << call_inst_string << "\n";
                            // Do nothing, but these may be signs of function pointers not being tracked
                        } else {
                            bool found_callee = false;

                            for (auto temp_node:call_graph_map[f_func->getName()]->successor_list) {
                                if (temp_node->function_string == callee) {
                                    found_callee = true;
                                }
                            }

                            if (!found_callee) {
                                call_graph_map[f_func->getName()]->successor_list.push_back(call_graph_map[callee]);
                                errs() << "\tAdding edge from: " << f_func->getName() << " to " << callee << "\n";
                            }
                        }
                    }






                } // END IF STORE INSTRUCTION
            } // END FOR F_INST =
        } // END FOR F_BLOCK =
    }







    /*
     * Re-Iterate over the call graph and map the call sites. The call graph generated by
     * LLVM is context sensitive in the sense that it contains an edge for every call site
     * but it does not contain information for the call sites.
     *
     * In order to gather line number information regarding call sites we must map all edges in the
     * call graph to their respective call sites.
     *
     * The only minor hurdle in this process is gathering the correct call
     * site when a function is called multiple times. To solve this we keep a record of the call sites
     * we have successfully visited.
     *
     * If function A calls function B multiple times we will count how many call sites for function B we have
     * visited and use that number as an index to find the next call site for function B
     */

    if (config->call_string_context_sensitive)
    {

        errs() << "Mapping call sites. This may take a few minutes!\n";

        std::map<std::string, CallNode*>::iterator graph_ittr = call_graph_map.begin();

        int highest_id = call_graph_map.size();

        for (;graph_ittr != call_graph_map.end(); graph_ittr++)
        {
            CallNode* temp_caller = graph_ittr->second;

            errs() << "\tFunction: " << temp_caller->function_string << "...";

            for (auto succ_it = temp_caller->successor_list.begin(); succ_it != temp_caller->successor_list.end(); succ_it++)
            {
                CallNode* temp_callee = (*succ_it);

                int func_count = how_many_calls_for_func_found(temp_caller, temp_callee->function_string);
                Instruction* call_inst = find_nth_call_in_function(temp_caller->function, temp_callee->function, func_count);

                if (call_inst != nullptr)
                {
                    std::string temp_inst;
                    llvm::raw_string_ostream rso(temp_inst);
                    call_inst->print(rso);

                    // At this point we would generate a call site with the appropriate information
                    CallSiteInst* new_call_site = new CallSiteInst(temp_caller->function, temp_callee->function, call_inst);

                    new_call_site->caller_function_string = temp_caller->function_string;
                    new_call_site->caller = temp_caller;
                    new_call_site->callee_function_string = temp_callee->function_string;
                    new_call_site->callee = temp_callee;
                    new_call_site->call_inst_string = temp_inst;
                    new_call_site->id = ++highest_id;

                    // Access the metadata and print out the corresponding line number for inst.
                    if (DILocation *loc = call_inst->getDebugLoc()) {
                        unsigned line_number = loc->getLine();
                        StringRef file = loc->getFilename();
                        StringRef dir = loc->getDirectory();

                        stringstream ss;
                        ss << line_number;
                        string lineString = ss.str();

                        new_call_site->directory_path = dir.str();
                        new_call_site->filename = file.str();
                        new_call_site->line_number = lineString;

                    }
                    temp_caller->call_sites.push_back(new_call_site);

                }
                else
                {
                    errs() << "Anomaly in call graph. Extra edge for function call that does not exist.\n";
                }
            }
            errs() << "DONE\n";
        }
    }



    //Debugging: This code will print out the call graph

    if (DEBUG) {
        std::map<std::string, CallNode*>::iterator node_it = call_graph_map.begin();
        for (; node_it != call_graph_map.end(); node_it++)
        {
            errs() << node_it->second->function_string << " : " << node_it->second->call_sites.size() << "\n";
            for (auto temp_node = node_it->second->successor_list.begin(); temp_node != node_it->second->successor_list.end(); temp_node++)
            {
                errs() << "\t" << (*temp_node)->function_string << "\n";
            }
        }
    }
}

std::list<Instruction*> CallGraphHelper::find_call_sites_for_function(Function* caller_function, std::list<std::string> callee_list) {

    std::list<Instruction*> call_sites;

    std::map<std::string, int> instruction_map;
    for (auto f_block = caller_function->begin(); f_block != caller_function->end(); f_block++) {
        for (auto f_inst = f_block->begin(); f_inst != f_block->end(); f_inst++) {

            if (CallInst * call_inst = dyn_cast<CallInst>(f_inst)) {
                std::string call_inst_string;
                raw_string_ostream rso(call_inst_string);
                call_inst->print(rso);

                std::string call_post_substring = call_inst_string.substr(call_inst_string.find('@') + 1, call_inst_string.size()-1);
                std::string caller = call_post_substring.substr(0, call_post_substring.find("("));

                if (caller.find(" ") != std::string::npos) {
                    caller = caller.substr(0, caller.find(" "));
                }

                // Only want unique call instructions, keep map in case duplicates
                if (instruction_map[call_inst_string] == 0) {
                    for (auto callee_string: callee_list) {
                        if (call_inst_string.find(callee_string) != std::string::npos) {
                            instruction_map[call_inst_string] = 1;
                            call_sites.push_back(call_inst);
                        }
                    }
                }
            } // END IF STORE INSTRUCTION
        } // END FOR F_INST =
    } // END FOR F_BLOCK =


    return call_sites;
}


std::map<std::string, CallNode*> CallGraphHelper::generate_function_call_graph(Function* starting_function, std::map<std::string, CallNode*> call_map, std::list<std::string> terminating_functions) {

    std::map<std::string, CallNode*> function_call_graph;

    bool stop_at_sink = false;

    if (terminating_functions.size() > 0) {
        stop_at_sink = true;
    }


    // Find a suitable root node. Either a source function if specified in the configuration or main
    CallNode* root_node;
    bool found_source_func = false;

    if (call_map[starting_function->getName().str()])
    {
        root_node = call_map[starting_function->getName().str()];
        found_source_func = true;
    } else
    {
        errs() << "Starting function for function call graph not present" << "\n";
    }

    // Active worklist to add nodes to for while loop
    std::list<CallNode*> work_list;
    work_list.push_back(root_node);

    // Keep track of visited nodes (prevents infinite looping)
    std::map<CallNode*, int> visited_nodes;

    while(!work_list.empty())
    {
        CallNode* temp_node = work_list.front();

        if (visited_nodes.count(temp_node) == 0)
        {
            visited_nodes[temp_node] = 1;
            function_call_graph[temp_node->function_string] = temp_node;

            if (stop_at_sink)
            {
                if (!is_auth_func(temp_node->function_string, terminating_functions))
                {
                    for (auto temp_it = temp_node->successor_list.begin(); temp_it != temp_node->successor_list.end(); temp_it++)
                    {
                        CallNode* succ_node = (*temp_it);
                        if (visited_nodes.count(succ_node) == 0)
                        {
                            work_list.push_back(succ_node);
                        }
                    }
                }
            } else {
                for (auto temp_it = temp_node->successor_list.begin(); temp_it != temp_node->successor_list.end(); temp_it++)
                {
                    CallNode* succ_node = (*temp_it);
                    if (visited_nodes.count(succ_node) == 0)
                    {
                        work_list.push_back(succ_node);
                    }
                }
            }
        }
        work_list.pop_front();
    }

    return function_call_graph;
}

bool CallGraphHelper::is_auth_func(std::string current, std::list<std::string> auth_functions) {

    bool is_auth_string = false;

    for (auto auth_string : auth_functions) {
        if (auth_string == current) {
            is_auth_string = true;
        }
    }

    return is_auth_string;
}



void CallGraphHelper::populate_function_map(CallNode* root_node, std::map<std::string, CallNode*> call_map) {


    std::list<CallNode*> work_list;
    work_list.push_back(root_node);

    std::map<CallNode*, int> visited_nodes;

    while(!work_list.empty())
    {
        CallNode* temp_node = work_list.front();

        if (visited_nodes.count(temp_node) == 0)
        {
            visited_nodes[temp_node] = 1;
            call_strings_function_map[temp_node->function_string] = 1;


            for (auto temp_it = temp_node->successor_list.begin(); temp_it != temp_node->successor_list.end(); temp_it++)
            {
                CallNode* succ_node = (*temp_it);
                if (visited_nodes.count(succ_node) == 0)
                {
                    work_list.push_back(succ_node);
                }
            }
        }
        work_list.pop_front();
    }
}

void CallGraphHelper::generate_call_strings(std::string source_function, std::string sink_function, int call_depth, bool output_to_dot, bool output_to_stdin)
{

    errs() << "Generating call strings for: " << source_function << " to " << sink_function << "\n";

    // Grab the source and sink function from the call graph
    CallNode* root_node = call_graph_map[source_function];
    CallNode* sink_node = call_graph_map[sink_function];

    // Set up a starting path with the root node
    std::list<CallSiteInst*> curr_path;
    std::map<std::string, int> visited_map;

    CallSiteInst* temp_root_inst = new CallSiteInst(root_node->function);
    temp_root_inst->id = 9000000;
    temp_root_inst->callee = root_node;
    temp_root_inst->callee_function_string = root_node->function_string;
    temp_root_inst->line_number = "N/A";
    temp_root_inst->directory_path = "N/A";
    temp_root_inst->filename = "N/A";

    curr_path.push_back(temp_root_inst);

    // Create a container to hold all paths found
    std::list<std::list<CallSiteInst*>> path_set;

    recursive_call_strings_sink_function(&path_set, &curr_path, sink_node, call_depth - 1);

    if (output_to_dot)
    {
        std::string dot_output_filename =  root_node->function_string + "_call_strings";
        call_strings_to_dot(path_set, call_graph_map, sink_node, dot_output_filename);
    }

    if (DEBUG) {
        for (auto path_it = path_set.begin(); path_it != path_set.end(); path_it++)
        {
            errs() << "Path: \n";
            std::list<CallSiteInst*> temp_list = (*path_it);

            for (auto node_it = temp_list.begin(); node_it != temp_list.end(); node_it++)
            {
                CallSiteInst* temp_site = (*node_it);
                errs() << "\tNode: " << temp_site->callee_function_string << "\n";
            }
        }
    }
}


void CallGraphHelper::recursively_add_callsites_to_map(std::map<std::string, CallSiteInst*> *callsite_map, std::map<std::string, CallNode*> *visited_map, std::list<CallSiteInst*> path, CallSiteInst* next_site, CallSiteInst* callsite)
{


    CallNode* temp_node = callsite->callee;

    std::list<CallSiteInst*> callsites = temp_node->call_sites;

    // Check if we reached the sink if so, add function to visited and return
    CallNode* sink_node = path.back()->callee;
    if (callsite->callee_function_string.find(sink_node->function_string) != std::string::npos)
    {
        (*visited_map)[sink_node->function_string] = sink_node;
        return;
    }

    // Check if we already visited this node, if so return
    if ((*visited_map).count(temp_node->function_string) > 0)
    {
        return;
    }
    else
    {
        (*visited_map)[temp_node->function_string] = temp_node;
    }

    for (auto callsite_it = callsites.begin(); callsite_it != callsites.end(); callsite_it++)
    {
        CallSiteInst* temp_cs = (*callsite_it);
        if ((*callsite_map).count(temp_cs->call_inst_string) == 0)
        {
            (*callsite_map)[temp_cs->call_inst_string] = temp_cs;
        }

        if (temp_cs->call_inst_string.find(next_site->call_inst_string) != std::string::npos)
        {
            // If we found the next callsite we want to update the next callsite after this then break
            // after getting recursive calls. The point being we dont want to capture any callsites
            // for this function after we identify the next site on the path to ensure we dont
            // accidentally add unnecessary paths that are represented in other files.


            recursively_add_callsites_to_map(callsite_map, visited_map, path, ++next_site, temp_cs);
            break;
        }
        else
        {
            recursively_add_callsites_to_map(callsite_map, visited_map, path, next_site, temp_cs);
        }

    }
}

void CallGraphHelper::recursive_call_strings_sink_function(std::list<std::list<CallSiteInst*>> *path_set, std::list<CallSiteInst*> *curr_path, CallNode *sink_node, int call_depth)
{
    // Gather information on the current node just added to the visited queue
    CallNode* curr_callnode = call_graph_map[curr_path->back()->callee_function->getName().str()];
    call_strings_function_map[curr_path->back()->callee_function->getName().str()] = 1;

    // Gather list of call sites
    std::list<CallSiteInst*> temp_callsite_list = curr_callnode->call_sites;

    while(!temp_callsite_list.empty())
    {

        // Gather information for the next call site to analyze
        CallSiteInst* next_callsite = temp_callsite_list.front();
        std::string next_function = next_callsite->callee_function_string;

        // Get rid of first call site so we know we are done when the temp list is empty
        temp_callsite_list.pop_front();



        // Check if the next function is our sink function, if so we found a path to record.
        if (next_function.find(sink_node->function_string) != std::string::npos)
        {
            call_strings_function_map[sink_node->function_string] = 1;
            curr_path->push_back(next_callsite);
            path_set->push_back(*curr_path);
            curr_path->pop_back();
        }
        else
        {
            bool function_already_on_path = false;
            // Quickly check that function has not already been visited on call path
            for (auto cs_it = curr_path->begin(); cs_it != curr_path->end(); cs_it++)
            {
                if ((*cs_it)->callee_function_string.find(next_function) != std::string::npos)
                {
                    function_already_on_path = true;
                }
            }

            if (!function_already_on_path)
            {
                curr_path->push_back(next_callsite);
                recursive_call_strings_sink_function(path_set, curr_path, sink_node, call_depth - 1);
                curr_path->pop_back();
            }
        }
    }
}



void CallGraphHelper::toDot(CallNode* root_node, std::map<std::string, CallNode*> call_map, std::string filename, std::string module_name)
{
    std::string ErrorInfo;
    sys::fs::OpenFlags Flags;
    std::error_code errCode;

    raw_fd_ostream File(filename.c_str(), errCode,Flags);

    if (!ErrorInfo.empty()) {
        errs() << "Error opening file " << filename
               << " for writing! Error Info: " << ErrorInfo << " \n";
        return;
    }

    this->toDot(root_node, call_map, &File, module_name);
}

void CallGraphHelper::toDot(CallNode* root_node, std::map<std::string, CallNode*> call_map, raw_ostream *stream, std::string module_name)
{
    (*stream) << "digraph \"Call Graph for \'" << module_name << "\'  \"{\n";
    (*stream) << "label=\"Call Graph for \'" << module_name << "\' \";\n";

    std::list<CallNode*> work_list;
    work_list.push_back(root_node);

    std::map<CallNode*, int> visited_nodes;

    while(!work_list.empty())
    {
        CallNode* temp_node = work_list.front();

        if (visited_nodes.count(temp_node) == 0)
        {
            (*stream) << "Node_" << temp_node->id << "[shape=box"  << ",style=solid" << ",label=\"" << temp_node->function_string << "\"]\n";
            visited_nodes[temp_node] = 1;


            for (auto temp_it = temp_node->successor_list.begin(); temp_it != temp_node->successor_list.end(); temp_it++)
            {
                CallNode* succ_node = (*temp_it);
                if (visited_nodes.count(succ_node) == 0)
                {

                    (*stream) << "\"" << "Node_"<<temp_node->id << "\"";

                    (*stream) << "->";

                    //Destination
                    (*stream) << "\"" << "Node_"<<succ_node->id  << "\"";
                    (*stream) << "\n";
                    work_list.push_back(succ_node);
                }
            }
        }
        work_list.pop_front();
    }

    (*stream) << "}\n\n";

}

void CallGraphHelper::call_strings_to_file(std::list<std::list<CallSiteInst*>> path_set, std::map<std::string, CallNode*> call_map, std::string filename)
{
    std::ofstream file_stream;
    file_stream.open(filename, std::ofstream::out | std::ofstream::trunc);


    file_stream.close();
}


void CallGraphHelper::call_strings_to_dot(std::list<std::list<CallSiteInst*>> path_set, std::map<std::string, CallNode*> call_map, CallNode* sink_node, std::string filename)
{
    // We will print out each path in its own dot file.
    // While all call string paths could be represented in a single graph it becomes very messy very fast
    int path_index = 1;


    // For each path, tack on the index to the filename and print the graph to a dot file.
    for (auto path_it:path_set)
    {

        std::string indexed_file_name = filename + "_path" + itostr(path_index) + ".dot";

        std::ofstream file_stream;
        file_stream.open(indexed_file_name, std::ofstream::out | std::ofstream::trunc);

        this->call_string_path_to_dot(path_it, call_map, sink_node, &file_stream);

        file_stream.close();

        path_index++;
    }


}

void CallGraphHelper::call_string_path_to_dot(std::list<CallSiteInst*> path, std::map<std::string, CallNode*> call_map, CallNode* sink_node, std::ofstream *stream) {

    (*stream) << "digraph \"Call Graph for \'" << "call_strings" << "\'  \"{\n";
    (*stream) << "label=\"Call Graph for \'" << "call_strings" << "\' \";\n";


    std::list<CallSiteInst *> temp_path = path;

    // Create map of all call sites seen on path and assign id's for any callsite without an id
    std::map<std::string, CallSiteInst*> callsite_map;
    // A map to keep track of the function nodes we have visited already
    std::map<std::string, CallNode*> visited_map;

    for (auto callsite_it = temp_path.begin(); callsite_it != temp_path.end(); callsite_it++)
    {

        // Quick check incase any callsite was not given an id
        CallSiteInst* temp_cs = (*callsite_it);
        callsite_map[temp_cs->call_inst_string] = temp_cs;
    }

    if (temp_path.size() > 1)
    {
        CallSiteInst* actual_start = temp_path.front();
        _List_iterator<CallSiteInst *> next = std::next(temp_path.begin(), 1);


        recursively_add_callsites_to_map(&callsite_map, &visited_map, path, (*next), actual_start);
    }



    // Now add each callsite and each node to the graph
    std::map<std::string, CallNode*>::iterator visited_it = visited_map.begin();

    for (; visited_it != visited_map.end(); visited_it++)
    {
        CallNode* temp_node = visited_it->second;
        (*stream) << "Node_" << temp_node->id << "[shape=box"  << ",style=solid" << ",label=\"" << temp_node->function_string << "\"]\n";
    }

    std::map<std::string, CallSiteInst*>::iterator callsite_it = callsite_map.begin();

    // Iterate through all callsites and add callsite nodes and edges between callsites and respective callnodes
    for (; callsite_it != callsite_map.end(); callsite_it++)
    {
        CallSiteInst* temp_cs = callsite_it->second;


        if (temp_cs->line_number.find("N/A") != std::string::npos)
        {
            (*stream) << "Node_" << temp_cs->id << "[shape=box"  << ",style=solid" << ",label=\"Root\"]\n";
        }
        else
        {
            (*stream) << "Node_" << temp_cs->id << "[shape=box"  << ",style=solid" << ",label=\"" << temp_cs->call_inst_string << "\n" << temp_cs->filename << ":" << temp_cs->line_number << "\"]\n";
        }


        CallNode* temp_node = temp_cs->callee;

        (*stream) << "\"" << "Node_"<<temp_cs->id << "\"";
        (*stream) << "->";
        (*stream) << "\"" << "Node_"<<temp_node->id  << "\"";
        (*stream) << "\n";
    }

    visited_it = visited_map.begin();

    // Re-Iterate through visited nodes and add an edge to respective call sites
    for (; visited_it != visited_map.end(); visited_it++)
    {
        CallNode* temp_node = visited_it->second;

        for (CallSiteInst* callsite_it: temp_node->call_sites)
        {
            if (callsite_map.count(callsite_it->call_inst_string) > 0)
            {
                CallSiteInst* temp_cs = callsite_map[callsite_it->call_inst_string];

                (*stream) << "\"" << "Node_"<<temp_node->id << "\"";
                (*stream) << "->";
                (*stream) << "\"" << "Node_"<<temp_cs->id  << "\"";
                (*stream) << "\n";
            }
        }
    }
    (*stream) << "}\n\n";
}

int CallGraphHelper::how_many_calls_for_func_found(CallNode* caller_node, std::string function_name)
{
    int function_counter = 0;

    std::list<CallSiteInst*> temp_site_list = caller_node->call_sites;

    for (auto call_site_it = temp_site_list.begin(); call_site_it != temp_site_list.end(); call_site_it++)
    {
        CallSiteInst* temp_callsite = (*call_site_it);

        StringRef temp_string = (*call_site_it)->callee_function->getName();

        if(temp_string.find(function_name) != std::string::npos)
        {
            function_counter++;
        }
    }

    return function_counter;
}

Instruction* CallGraphHelper::find_nth_call_in_function(Function* caller, Function* callee, int num_funcs_before)
{

    int num_funcs = 0;
    for (auto block_it = caller->begin(); block_it != caller->end(); block_it++)
    {
        for (auto inst_it = block_it->begin(); inst_it != block_it->end(); inst_it++)
        {
            Instruction* temp_inst = (&*inst_it);

            if (CallInst* call_inst = dyn_cast<CallInst>(temp_inst))
            {

                std::string call_inst_string;
                llvm::raw_string_ostream rso(call_inst_string);
                call_inst->print(rso);

                if (call_inst_string.find(callee->getName().str()) != std::string::npos) {
                    if (num_funcs == num_funcs_before)
                    {
                        return call_inst;
                    }
                    else
                    {
                        num_funcs++;
                    }
                }
            }
        }
    }

    return nullptr;
}

std::map<std::string, CallNode *> CallGraphHelper::get_call_map() {
    return call_graph_map;
}

std::map<std::string, int> CallGraphHelper::get_call_strings_function_map() {
    return call_strings_function_map;
}



namespace ProgramInfoHelper
{


}








